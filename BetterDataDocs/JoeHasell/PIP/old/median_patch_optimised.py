# %%
#Starting from an adjusted mean, the code evaluates the headcount ratio associated with it and increases or diminishes
#the median candidate until the value of the headcount ratio is between 0.49 and 0.51 to be as close as possible to the median
#Increments vary depending on how far to the ]0.49, 0.51[ range the number is.

start_time = time.time()

#Limits and increment when headcount values are between 0.45 to 0.49 and 0.51 to 0.55
lower_limit = 0.49
upper_limit = 0.51
increment = 0.025

#Limits and increment when headcount values are between 0.4 to 0.45 and 0.55 to 0.6
lower_limit_close = 0.45
upper_limit_close = 0.55
increment_close = 0.1

#Limits and increment when headcount values are between 0 to 0.4 and 0.6 to 1
lower_limit_far = 0.4
upper_limit_far = 0.6
increment_far = 0.3

#There is an adjunstment value for the mean seed value, as the median is commonly less than the mean
mean_adjustment = 2

#Generate a fresh dataframe with missing and non-missing medians
df_query = pip_query_country(
                    popshare_or_povline = "povline", 
                    value = 1.9, 
                    fill_gaps="false")

#Initialise the median list, which will combine the replacements for the null medians with the non-missing medians
median_list = []

for i in range(len(df_query)):
    #If the median is null...
    if np.isnan(df_query['median'][i]):
        #Define the mean minus the mean adjustment as the median candidate. If difference is negative, select 0.1
        median_candidate = max(df_query['mean'][i] - mean_adjustment,0.1)
        headcount_ratio = 0
        
        #Run this while the estimated headcount ratio is not between the lower and upper limits
        while headcount_ratio < lower_limit or headcount_ratio > upper_limit:
            #Run a PIP query for each observation with null median, but using the median candidate as poverty line
            df_candidate = pip_query_country(popshare_or_povline = "povline",
                                            country_code = df_query['country_code'][i],
                                            year = df_query['reporting_year'][i],
                                            welfare_type = df_query['welfare_type'][i],
                                            reporting_level = df_query['reporting_level'][i],
                                            value = median_candidate,
                                            fill_gaps="false")
            
            #The headcount ratio for the median candidate is taken
            headcount_ratio = df_candidate['headcount'][0]
            
            print(f'{i}, median {median_candidate}, headcount {headcount_ratio}')
            
            #Different increments are defined depending on the value of headcount_ratio
            if headcount_ratio < lower_limit_far:
                median_candidate += increment_far
                
            elif headcount_ratio > upper_limit_far:
                median_candidate -= increment_far
                
            elif headcount_ratio < lower_limit_close:
                median_candidate += increment_close
                
            elif headcount_ratio > upper_limit_close:
                median_candidate -= increment_close
            
            elif headcount_ratio < lower_limit:
                median_candidate += increment
            
            elif headcount_ratio > upper_limit:
                median_candidate -= increment
                
        #After the "while" cycle I get a median which generates a headcount ratio between the lower and upper limits
        #Include this value into the median list
        median_list.append(median_candidate)
        
    #If the median is not null...
    else:
        #Keep the median and append it to the median list
        median_value = df_query['median'][i]
        median_list.append(median_value)
               
#Save the median list as a new column
df_query['median2'] = median_list
#Rename columns to OWID standard
df_query = df_query.rename(columns={'country_name': 'Entity',
                                    'reporting_year': 'Year'})
#Median nulls in original and new columns
null_median = (df_query['median'].isnull()).sum()
null_median2 = (df_query['median2'].isnull()).sum()

#Print these two different values to show the change generated by the patch 
print(f'Before patching: {null_median} nulls for median')
print(f'After patching: {null_median2} nulls for median')

#The results are merged to the df_final dataframe
df_final = pd.merge(df_final, df_query[['Entity', 'Year', 'welfare_type', 'reporting_level', 'median2']], 
                       how='left', 
                       on=['Entity', 'Year', 'welfare_type', 'reporting_level'], 
                       validate='many_to_one')

#This is a quick last check to compare previous and new median values
df_final['median_ratio'] = df_final['median'] / df_final['median2']
median_ratio_median = (df_final['median_ratio']).median()
median_ratio_min = (df_final['median_ratio']).min()
median_ratio_max = (df_final['median_ratio']).max()

if median_ratio_median == 1 and median_ratio_min == 1 and median_ratio_max == 1:
    print(f'Patch successful.')
    print(f'Ratio between old and new variable: Median = {median_ratio_median}, Min = {median_ratio_min}, Max = {median_ratio_max}')
else:
    print(f'Patch changed some median values. Please check for errors.')
    print(f'Ratio between old and new variable: Median = {median_ratio_median}, Min = {median_ratio_min}, Max = {median_ratio_max}')

#Drop the check and the old median and rename the new median
df_final.drop(columns=['median', 'median_ratio'], inplace=True)
df_final.rename(columns={'median2': 'median'}, inplace=True)


end_time = time.time()
elapsed_time = end_time - start_time
print('Execution time:', elapsed_time, 'seconds')
