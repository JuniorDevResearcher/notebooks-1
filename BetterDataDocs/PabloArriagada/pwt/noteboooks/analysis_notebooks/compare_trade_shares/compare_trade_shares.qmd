---
title: OWID Data document – Calculating a measure of trade openness from the Penn World Tables
format: html
toc: true
jupyter:
  jupytext:
    formats: 'qmd:quarto,ipynb'
    text_representation:
      extension: .qmd
      format_name: quarto
      format_version: '1.0'
      jupytext_version: 1.13.8
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

# OWID Data document – Calculating a measure of trade openness from the Penn World Tables

### About OWID Data documents

OWID data documents combine computer code and text to explain and document the data we and how we prepare it from the original sources.

We make these documents available in different formats:

- See this document in [GitHub](https://github.com/owid/notebooks/blob/main/BetterDataDocs/PabloArriagada/pwt/noteboooks/analysis_notebooks/compare_trade_shares/compare_trade_shares.qmd)
- Open a runnable version in [Google Colabs](https://colab.research.google.com/drive/19ubTKaA_b_6gjaSvpuhhwwek1BvK3xYq)


If you have this open in Google Colabs, you can run the code blocks below and see their outputs. Clicking on **'Copy to Drive'** in the menu bar above will open up a new copy in your own Google Drive that you can then _edit_ the code to explore the data further.

## Trade data in the Penn World Tables


Penn World Tables 10.0 (_PWT_) includes two data files:

- the main data file contains series that have applied various price adjustments in order to make series that are comparable across countries. The data is expressed in _international-$_, calculated in various ways.
- a separate 'National Accounts' data file which provides data in _local currencies_ (alongside market exchange rates that allow you to convert to USD).


Both files contain series relating to trade data.

We would like to produce a series for trade openness – measured as imports plus exports as a share of GDP. As well as presenting country-level data on this variable – shown in [this chart](https://ourworldindata.org/grapher/trade-openness) – we also produce a global aggregate measure of trade openness – as shown in our [Globalization over 5 centuries](https://ourworldindata.org/grapher/globalization-over-5-centuries-km) chart.

At first glance, this measure seems possible to calculate from either of the two data files in _PWT_. However, as we show in this notebook, doing so yields different results.

In this notebook we compare the two approaches and explain why we have decided to use the National Accounts data in our charts of trade openness.

```{python}
#| code-fold: true
#| code-summary: 'Set-up: load packages'

#Load packages
import pandas as pd
import plotly.express as px
import numpy as np
```

## Trade data in the National Accounts data file

```{python}
#| code-fold: true
#| code-summary: 'Set-up: read in National Accounts data'

#National accounts data file – after country names have been standardized
url = "https://joeh.fra1.digitaloceanspaces.com/pwt/entities_standardized_national_accounts.csv"


df_na = pd.read_csv(url)
```

The National Accounts data file provides us with the value of exports and imports expressed in local currencies – in both current prices (i.e. not adjusted for inflation) and constant 2017 prices (i.e adjusted for inflation in each country).

The file also provides us with GDP (again measured in local currencies at both current and constant prices).

We calculate exports and imports as shares of GDP using the current price data – that is, everything measured in local currencies in nominal terms, without adjusting for inflation.


#### A note on constant price trade data in the national accounts

In addition to the current price data, we calculated trade shares using the constant price data, expecting to find the same figures. In fact they were quite different, implying that the numerator (the trade flows) are mutiplied by a diferent number to the denominator (GDP) when the figures are adjusted for inflation.

We present a comparison of these series with further discussion in the Appendix below.



#### A note on the entities in the National Accounts data file

The National Accounts data file includes observations for some former states (USSR, Yugoslavia, Czechoslovakia), although no GDP or trade data is available for these former states in the file.

It also includes _two_ series for China: the current price data (and population) is the same across the two series, but the constant price data is different (i.e. the second entry applies a different price index series to adjust the nominal data for inflation). See note in Appendix below for furhter discussion.

In calculating a global aggregate series for trade openness, we drop the second China series (so as to not overly weight China in the calculation). The former states are dropped in the calculation in an case since they have no GDP or trade data.



#### Trade openness – individual countries

To calulate trade openness for individul countries, we divde the sum of imports and exports (both of which are given as positive values in the data) by GDP – all measured in current prices (without any adjustment for inflation).

```{python}
df_na['trade_openness'] = (df_na['v_x'] + df_na['v_m'])/df_na['v_gdp']
```

#### Trade openness – global aggregate

To produce a global aggregate, we take the weighted average across countries, using for weights the same measure of GDP as used to calculate the trade shares.

However, as the national accounts data are given in local currencies we first convert the latter to a common currency (USD). The national accounts file provides exchange rates (national currency/USD) for this purpose.

(Note that the calculation is equivalent to dividing aggregate trade flows by aggregate GDP – both converted to USD).

The average is calculated across all countries with available data in each year, and hence which countries are included in the average changes over time. In the Appendix below we discuss coverage across countries.

```{python}
df_na['v_gdp_usd'] = df_na['v_gdp']/df_na['xr2'] 

# Weighted average (dropping alt China series and NaNs)
world_trade_openness_na = df_na[df_na['entity']!='China (alternative inflation series)']\
     .dropna(subset=['trade_openness', 'v_gdp_usd'], how = 'all')\
     .groupby("year").apply(lambda x: np.average(x['trade_openness'], weights=x['v_gdp_usd'])).reset_index()

world_trade_openness_na.columns = ['year', 'World trade openness']
```

## Trade data in the main PWT data file

```{python}
#| code-fold: true
#| code-summary: 'Set-up: read in main data'

#Main data file – after country names have been standardized
url = "https://joeh.fra1.digitaloceanspaces.com/pwt/entities_standardized.csv"

df_main = pd.read_csv(url)
```

There are two trade variables within the main data: "Share of merchandise exports at current PPPs" (`csh_x`) and "Share of merchandise imports at current PPPs" (`csh_m`).



#### Trade openness – individual countries

To calculate trade openness we can simply sum the import and export shares.

#### Note on the sign of the import and export share variables
In the boxplots below we see that, in general, exports are positive numbers and imports are negative numbers – such that exports plus imports give you net exports as a share of GDP). 

However there are a few cases – a handful of years for Bermuda – where the reverse holds (see Appendix). It's not clear how these observations with a reversed sign should be interpreted. In any case, we take the absolute value of the import and export shares in calculating the trade openness metric below.

```{python}
# Calculate trade openness – use absolute values
df_main['trade_openness'] = (abs(df_main['csh_x']) + abs(df_main['csh_m']))
```

#### Trade openness – global aggregate

To calculate a global aggregate, we can take the weighted average of our country-level trade openness data, where for weights we use the same GDP measure used in the calculation of the trade shares.

#### Note – What is the denominator of the trade share variables in the main PWT data file?

As documented in the the original data file, these import/export shares are _shares in `CGDPo`_. `CGDPo` is one of the GDP series available in _PWT_. It is GDP measured in terms of output, using a single benchmark year to adjust for differences in the cost living across countries (as opposed to multiple benchmarks). See our further discussion of the difference between the GDP variables in _PWT_ **here**. (PROVIDE LINK WHEN DONE).

```{python}
# Weighted average, dropping NaNs
world_trade_openness_main = df_main.dropna(subset=['trade_openness', 'cgdpo'], how = 'any').groupby("year").apply(lambda x: np.average(x['trade_openness'], weights=x['cgdpo'])).reset_index()

world_trade_openness_main.columns = ['year', 'World trade openness']
```

## Compare National Accounts and Main data


Here we plot the two global aggregate trade openness series.

We see that the two sets of data yield quite different series – although the trends are similar.

```{python}
#| code-fold: true
#| code-summary: Plot different global aggregates together

#Reshape and stack together to plot
world_trade_openness_na['source'] = 'National Accounts – current prices'


#Taking the 'incomplete' coverage series calculated above from the main data file
world_trade_openness_main['source'] = "Main data – international-$ (single benchmark)"

# Stack together
df_plot= pd.concat([world_trade_openness_na,world_trade_openness_main])

fig = px.line(df_plot, x = 'year', y='World trade openness', 
     title = "World trade openness – two series from PWT",
     color = 'source')
fig.show()
```

**Why are the series different?**

First, as we discuss in the Appendix, country coverage is different between the two files. Coverage is considerably better for the National Accounts data. However even for the recent period where coverage is complete in both files, the series are different.

Second, the trade shares for individual countries are different in the different datasets (see Appendix). This implies that, in adjusting the National Accounts data to arrive at the tade series in the main data, the numerators (the trade flows) are being mutiplied by a diferent number than the denominators (GDP).

**Why do we use the National Accounts data in our charts**

The series for trade openess we use in our charts is calculated from the current price data available in the _PWT_ National Accounts data file. i.e. from series in which no adjustment has been made for inflation or for price differences across countries.

When coming to this question our assumption was that such adjustments would not affect the trade shares – as we expected both the numerator (the trade flows) and the denominator (GDP) to be adjusted by the same factor. As we discuss in the Appendix, this is not the case: the trade shares presented in the main data file – which make adjustments for inflation and for cross-country price differences – are different to those we calculate from the National Accounts data.

Since we don't fully understand the price adjustments and why they should affect the trade shares, for our measure of trade opennes we use the current price data from the Natonal Accounts file, which does not apply any price adjustments.

The National Accounts data also has much higher coverage than the main data file, which is especially important when calculting the global aggregate.


## Appendix


### Comparing trade shares in the National Accounts and main data files

Here we plot the trade shares data available from the main file and the National Accounts files against each other. The fact that that many observations fall far from the 45-degree line shows that there are large differences between the two sets of data.

(Note the range of the plot has been restricted to make this clearer.)

```{python}
#| code-fold: true
#| code-summary: Calculate shares and plot

# Prep trade shares from National Accounts data
df_exports_na = df_na[['year', 'entity', 'v_x', 'v_gdp']].copy()
df_imports_na = df_na[['year', 'entity', 'v_m', 'v_gdp']].copy()

#Current price shares
df_exports_na['National Accounts – current price'] = df_exports_na['v_x']/df_exports_na['v_gdp'] * 100
df_imports_na['National Accounts – current price'] = df_imports_na['v_m']/df_imports_na['v_gdp'] * 100

df_exports_na.drop(columns=['v_x', 'v_gdp'], inplace=True)
df_imports_na.drop(columns=['v_m', 'v_gdp'], inplace=True)

#Prep trade shares from main data
df_exports_main = df_main[['year', 'entity', 'csh_x']].copy()
df_imports_main = df_main[['year', 'entity', 'csh_m']].copy()

df_exports_main['csh_x'] = df_exports_main['csh_x'] * 100
df_imports_main['csh_m'] = -df_imports_main['csh_m'] * 100

df_exports_main.rename(columns={"csh_x": "Main data"}, inplace=True)
df_imports_main.rename(columns={"csh_m": "Main data"}, inplace=True)

# Reshape for plot
#Pablo: I think the main problem was here: a merge was needed instead of a concat

df_imports = pd.merge(df_imports_na, df_imports_main, on=['year', 'entity'], validate='one_to_one')
df_imports['measure'] = 'imports'

df_exports = pd.merge(df_exports_na, df_exports_main, on=['year', 'entity'], validate='one_to_one')
df_exports['measure'] = 'exports'


df_plot = pd.concat([df_imports,df_exports])


# Facet scatter to compare 

fig = px.scatter(df_plot,
                 x = 'National Accounts – current price',
                 y = 'Main data',
                 log_x = False,
                 log_y = False, #False will show the weird Bermuda values and not too much detail
                 color = 'entity',
                 facet_col = 'measure',
                 opacity=0.5,
                 range_y=[-1, 250])
fig.show()
```

### Country coverage

**JH comment**: Pablo could you please add coverage pngs so we can a) see the coverage of which countries are included in the NA aggregation in any given year and b) see that the coverage in main data file is generally worse than the NA file.


### Comparing constant and current price trade data in the National Accounts data file.

Within the National Accounts data, there are series for both current and constand price data. 

Trade shares calculated according to the current and constant price data are different.

This implies that the numerator (the trade flows) are being mutiplied by a diferent number than the denominator (GDP) when the figures are adjusted for inflation.

```{python}
#| code-fold: true
#| code-summary: Calculate shares and plot


df_imports = df_na[['year', 'entity', 'v_m', 'v_gdp', 'q_m', 'q_gdp']].copy()
df_exports = df_na[['year', 'entity', 'v_x', 'v_gdp', 'q_x', 'q_gdp']].copy()

#Current price shares
df_imports['Current prices'] = df_imports['v_m']/df_imports['v_gdp'] * 100
df_exports['Current prices'] = df_exports['v_x']/df_exports['v_gdp'] * 100

#Constant price shares
df_imports['Constant prices'] = df_imports['q_m']/df_imports['q_gdp'] * 100
df_exports['Constant prices'] = df_exports['q_x']/df_exports['q_gdp'] * 100


df_imports['measure'] = "Imports/GDP"
df_exports['measure'] = "Exports/GDP"

df_plot = pd.concat([df_imports,df_exports])



fig = px.scatter(df_plot,
                 x = 'Current prices',
                 y = "Constant prices",
                 color = 'entity',
                 facet_col = 'measure',
                 opacity = 0.5
                )
fig.show()
```

The national accounts data file give a breakdown of GDP into other components. To try to understand what's going on with the price adjustments, I sum these up for the current and constand price data.

Note that the components of GDP do not always sum to one even in the current price data. But this is even more true of the constant price data. This again shows that the numerators are being multiplied by a different factor to the denominator, GDP, when adjusting for inflation.

```{python}
#| code-fold: true
#| code-summary: Check components of current price GDP sum to one

df_na['composition_check_current'] = (df_na['v_c'] + 
                                    df_na['v_i'] +
                                    df_na['v_g'] +
                                    df_na['v_x'] -
                                    df_na['v_m'])/df_na['v_gdp']

df_na['composition_check_current'].describe()                                    
```

```{python}
#| code-fold: true
#| code-summary: Check components of constant price GDP sum to one

df_na['composition_check_constant'] = (df_na['q_c'] + 
                                    df_na['q_i'] +
                                    df_na['q_g'] +
                                    df_na['q_x'] -
                                    df_na['q_m'])/df_na['q_gdp']

df_na['composition_check_constant'].describe()                                    
```

### Comparison of two series for China available in the National Accounts data

Countries are identified in the national accounts data file only according to ISO 3 codes.

Within the file there is an entity `CH2` which doesn not correspond to any recognized ISO 3 code. On inspection it is clear that this entity refers to China, and is provided in addition to data labeled with the standard `CHN` ISO 3 code.

The two labels have the same data for nominal series (and population) but the constant price data is different between the two. You can see this in the chart below (toggle the series on and on off in the legend to see that the two lines are stacked on top of each other in the case of `v_gdp` and `pop`.)

```{python}
#| code-fold: true
#| code-summary: Plots to compare the two China series
china_entities = ['China', 'China (alternative inflation series)']

# Reshape for faceted plot
df_plot = df_na[df_na['entity'].isin(china_entities)][['entity', 'year', 'v_gdp','q_gdp','pop']]

df_plot = df_plot.melt(id_vars=['year','entity'], var_name='measure')

# Faceted line plot comparing the two China entities for different variables
fig = px.line(df_plot, x = 'year', y='value', 
    title = "Compare two China entities in the PWT national accounts data file",
    color = 'entity',
    facet_col='measure')
fig.show()
```

### The sign of trade shares in the main data file
In general, in the main data file the export shares are given as positive numbers and the import shares are given as negative numbers.

```{python}
#| code-fold: true
#| code-summary: Make boxplot of import and export shares
df_plot = df_main[['year','entity','csh_x', 'csh_m']]
df_plot = df_plot.melt(id_vars=['year','entity'], var_name='measure')

fig = px.box(df_plot, x = 'measure', y="value", range_y=[-7, 7])
fig.show()
```

There are a few years for Bermuda where the signs are reversed. It is not clear how these values should be interpreted.

```{python}
#| code-fold: true
#| code-summary: Show country years with reversed signs on the trade variables
# Show observations with either negative exports or positive imports.
df_main[(df_main['csh_x']<0) | (df_main['csh_m']>0)][['entity','year', 'csh_x', 'csh_m']]
```
