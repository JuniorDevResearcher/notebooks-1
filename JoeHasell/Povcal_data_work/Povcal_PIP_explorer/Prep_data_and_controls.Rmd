---
title: "Format Michalis' output for explorer"
author: "Joe Hasell"
date: "21/04/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(RCurl)
library(knitr)
library(readxl)
library(openxlsx)
```

##Prep the data

Read in Michalis' povcal data
```{r}
df <- read.csv("https://raw.githubusercontent.com/owid/notebooks/main/MichalisMoatsos/PovcalNetMainDataCountriesOnly.csv", row.names = 1, header = T, sep = ";", dec = ",")

```

Map 3-letter codes to country names
```{r}
name_mapping <- read.csv("entity_names_three_letter_country_standardized.csv") %>%
  rename(Entity = Country)

df<- left_join(df,name_mapping)

df<- df %>%
  select(-Entity) %>%
  rename(Entity = Our.World.In.Data.Name) %>%
  select(Entity, everything())

```

Rename vars (We should do rearrange Michalis' script to structure the variables like this and then delete this section)

```{r}


orig_varnames<- c(

"Entity",
"Year",
"X.1.per.day...share.of.population.below.poverty.line",
"X.1.per.day...poverty.gap.index",
"X.1.per.day...total.number.of.people.below.poverty.line",
"X.1.per.day...absolute.poverty.gap",
"X.1.per.day...income.gap.ratio",
"X.1.per.day...watts.index",
"X.1.9.per.day...share.of.population.below.poverty.line",
"X.1.9.per.day...poverty.gap.index",
"X.1.9.per.day...total.number.of.people.below.poverty.line",
"X.1.9.per.day...absolute.poverty.gap",
"X.1.9.per.day...income.gap.ratio",
"X.1.9.per.day...watts.index",
"X.3.2.per.day...share.of.population.below.poverty.line",
"X.3.2.per.day...poverty.gap.index",
"X.3.2.per.day...total.number.of.people.below.poverty.line",
"X.3.2.per.day...absolute.poverty.gap",
"X.3.2.per.day...income.gap.ratio",
"X.3.2.per.day...watts.index",
"X.5.5.per.day...share.of.population.below.poverty.line",
"X.5.5.per.day...poverty.gap.index",
"X.5.5.per.day...total.number.of.people.below.poverty.line",
"X.5.5.per.day...absolute.poverty.gap",
"X.5.5.per.day...income.gap.ratio",
"X.5.5.per.day...watts.index",
"X.10.per.day...share.of.population.below.poverty.line",
"X.10.per.day...poverty.gap.index",
"X.10.per.day...total.number.of.people.below.poverty.line",
"X.10.per.day...absolute.poverty.gap",
"X.10.per.day...income.gap.ratio",
"X.10.per.day...watts.index",
"X.15.per.day...share.of.population.below.poverty.line",
"X.15.per.day...poverty.gap.index",
"X.15.per.day...total.number.of.people.below.poverty.line",
"X.15.per.day...absolute.poverty.gap",
"X.15.per.day...income.gap.ratio",
"X.15.per.day...watts.index",
"X.20.per.day...share.of.population.below.poverty.line",
"X.20.per.day...poverty.gap.index",
"X.20.per.day...total.number.of.people.below.poverty.line",
"X.20.per.day...absolute.poverty.gap",
"X.20.per.day...income.gap.ratio",
"X.20.per.day...watts.index",
"X.30.per.day...share.of.population.below.poverty.line",
"X.30.per.day...poverty.gap.index",
"X.30.per.day...total.number.of.people.below.poverty.line",
"X.30.per.day...absolute.poverty.gap",
"X.30.per.day...income.gap.ratio",
"X.30.per.day...watts.index",
"X.40.per.day...share.of.population.below.poverty.line",
"X.40.per.day...poverty.gap.index",
"X.40.per.day...total.number.of.people.below.poverty.line",
"X.40.per.day...absolute.poverty.gap",
"X.40.per.day...income.gap.ratio",
"X.40.per.day...watts.index",
"X40..of.median.income...share.of.population.below.poverty.line",
"X40..of.median.income...poverty.gap.index",
"X40..of.median.income...total.number.of.people.below.poverty.line",
"X40..of.median.income...absolute.poverty.gap",
"X40..of.median.income...income.gap.ratio",
"X40..of.median.income...watts.index",
"X50..of.median.income...share.of.population.below.poverty.line",
"X50..of.median.income...poverty.gap.index",
"X50..of.median.income...total.number.of.people.below.poverty.line",
"X50..of.median.income...absolute.poverty.gap",
"X50..of.median.income...income.gap.ratio",
"X50..of.median.income...watts.index",
"X60..of.median.income...share.of.population.below.poverty.line",
"X60..of.median.income...poverty.gap.index",
"X60..of.median.income...total.number.of.people.below.poverty.line",
"X60..of.median.income...absolute.poverty.gap",
"X60..of.median.income...income.gap.ratio",
"X60..of.median.income...watts.index",
"MeanPerMonth",
"MeanPerMonth_estimated",
"MedianPerMonth",
"MedianPerMonth_estimated",
"PPP",
"Population",
"Decile.1...share.of.income.or.consumption",
"Decile.2...share.of.income.or.consumption",
"Decile.3...share.of.income.or.consumption",
"Decile.4...share.of.income.or.consumption",
"Decile.5...share.of.income.or.consumption",
"Decile.6...share.of.income.or.consumption",
"Decile.7...share.of.income.or.consumption",
"Decile.8...share.of.income.or.consumption",
"Decile.9...share.of.income.or.consumption",
"Decile.10...share.of.income.or.consumption",
"Decile.1...threshold.of.income.or.consumption.per.month",
"Decile.2...threshold.of.income.or.consumption.per.month",
"Decile.3...threshold.of.income.or.consumption.per.month",
"Decile.4...threshold.of.income.or.consumption.per.month",
"Decile.5...threshold.of.income.or.consumption.per.month",
"Decile.6...threshold.of.income.or.consumption.per.month",
"Decile.7...threshold.of.income.or.consumption.per.month",
"Decile.8...threshold.of.income.or.consumption.per.month",
"Decile.9...threshold.of.income.or.consumption.per.month",
"Decile.1...average.income.or.consumption.per.month",
"Decile.2...average.income.or.consumption.per.month",
"Decile.3...average.income.or.consumption.per.month",
"Decile.4...average.income.or.consumption.per.month",
"Decile.5...average.income.or.consumption.per.month",
"Decile.6...average.income.or.consumption.per.month",
"Decile.7...average.income.or.consumption.per.month",
"Decile.8...average.income.or.consumption.per.month",
"Decile.9...average.income.or.consumption.per.month",
"Decile.10...average.income.or.consumption.per.month",
"Gini.index",
"Gini_estimated",
"Polarization",
"Polarization_estimated",
"MLD",
"MLD_estimated",
"Palma",
"P90.P10.ratio",
"P90.50.ratio",
"Entropy_0_5",
"Entropy_1_0",
"Entropy_1_5",
"Entropy_2_0",
"Atkinson_0_5",
"Atkinson_1_0",
"Atkinson_1_5",
"Atkinson_2_0",
"Theil_0_0",
"Theil_0_5",
"Theil_1_0",
"Theil_1_5",
"Theil_2_0",
"Var.Coeff",
"datayear",
"isinterpolated",
"usemicrodata",
"coveragetype",
"datatype",
"IsSurveyYear",
"OriginalMedian",
"OriginalMean",
"OriginalDecileShares",
"MonotonicityBreaks",
"RowsWithIncreasingHeadcount",
"DataframeRowsForGpinter",
"LessThan33Rows",
"ISO3DataYearCovType",
"ISO3Year"
)


new_varnames<- c(

"Entity",
"Year",
"headcount_ratio_1_00",
"poverty_gap_index_1_00",
"headcount_1_00",
"total_shortall_annual_1_00",
"income_gap_ratio_1_00",
"watts_index_1_00",
"headcount_ratio_1_90",
"poverty_gap_index_1_90",
"headcount_1_90",
"total_shortall_annual_1_90",
"income_gap_ratio_1_90",
"watts_index_1_90",
"headcount_ratio_3_20",
"poverty_gap_index_3_20",
"headcount_3_20",
"total_shortall_annual_3_20",
"income_gap_ratio_3_20",
"watts_index_3_20",
"headcount_ratio_5_50",
"poverty_gap_index_5_50",
"headcount_5_50",
"total_shortall_annual_5_50",
"income_gap_ratio_5_50",
"watts_index_5_50",
"headcount_ratio_10_00",
"poverty_gap_index_10_00",
"headcount_10_00",
"total_shortall_annual_10_00",
"income_gap_ratio_10_00",
"watts_index_10_00",
"headcount_ratio_",
"poverty_gap_index_15_00",
"headcount_15_00",
"total_shortall_annual_15_00",
"income_gap_ratio_15_00",
"watts_index_15_00",
"headcount_ratio_20_00",
"poverty_gap_index_20_00",
"headcount_20_00",
"total_shortall_annual_20_00",
"income_gap_ratio_20_00",
"watts_index_20_00",
"headcount_ratio_30_00",
"poverty_gap_index_30_00",
"headcount_30_00",
"total_shortall_annual_30_00",
"income_gap_ratio_30_00",
"watts_index_30_00",
"headcount_ratio_40_00",
"poverty_gap_index_40_00",
"headcount_40_00",
"total_shortall_annual_40_00",
"income_gap_ratio_40_00",
"watts_index_40_00",
"headcount_ratio_40_median",
"poverty_gap_index_40_median",
"headcount_40_median",
"total_shortall_annual_40_median",
"income_gap_ratio_40_median",
"watts_index_40_median",
"headcount_ratio_50_median",
"poverty_gap_index_50_median",
"headcount_50_median",
"total_shortall_annual_50_median",
"income_gap_ratio_50_median",
"watts_index_50_median",
"headcount_ratio_60_median",
"poverty_gap_index_60_median",
"headcount_60_median",
"total_shortall_annual_60_median",
"income_gap_ratio_60_median",
"watts_index_60_median",
"MeanPerMonth",
"MeanPerMonth_estimated",
"MedianPerMonth",
"MedianPerMonth_estimated",
"PPP",
"Population",
"share_decile_1",
"share_decile_2",
"share_decile_3",
"share_decile_4",
"share_decile_5",
"share_decile_6",
"share_decile_7",
"share_decile_8",
"share_decile_9",
"share_decile_10",
"threshold_decile_1",
"threshold_decile_2",
"threshold_decile_3",
"threshold_decile_4",
"threshold_decile_5",
"threshold_decile_6",
"threshold_decile_7",
"threshold_decile_8",
"threshold_decile_9",
"average_decile_1",
"average_decile_2",
"average_decile_3",
"average_decile_4",
"average_decile_5",
"average_decile_6",
"average_decile_7",
"average_decile_8",
"average_decile_9",
"average_decile_10",
"Gini",
"Gini_estimated",
"Polarization",
"Polarization_estimated",
"MLD",
"MLD_estimated",
"Palma",
"P90_P10_ratio",
"P90_50_ratio",
"Entropy_0_5",
"Entropy_1_0",
"Entropy_1_5",
"Entropy_2_0",
"Atkinson_0_5",
"Atkinson_1_0",
"Atkinson_1_5",
"Atkinson_2_0",
"Theil_0_0",
"Theil_0_5",
"Theil_1_0",
"Theil_1_5",
"Theil_2_0",
"Var.Coeff",
"datayear",
"isinterpolated",
"usemicrodata",
"coveragetype",
"datatype",
"IsSurveyYear",
"OriginalMedian",
"OriginalMean",
"OriginalDecileShares",
"MonotonicityBreaks",
"RowsWithIncreasingHeadcount",
"DataframeRowsForGpinter",
"LessThan33Rows",
"ISO3DataYearCovType",
"ISO3Year"
)

varname_map<- data.frame(orig_varnames,new_varnames)


```


Swap in new varnames
```{r}
df<- df %>%
  pivot_longer(cols = !c(Entity, Year, coveragetype, datatype, ISO3Year, ISO3DataYearCovType, IsSurveyYear), names_to = "orig_varnames", values_to = "value")

# Merge in new var names

df<- left_join(df, varname_map)

# check there are no unmatched vars
br<- df %>%
  filter(is.na(new_varnames))

# drop original varnames
df<- df %>%
  select(-orig_varnames)

```




Demark Urban/Rural entities.
```{r}
df<- df %>%
  mutate(Entity = if_else(coveragetype == "R",
                          paste0(Entity, " -  Rural"),
                          Entity)) %>%
  mutate(Entity = if_else(coveragetype == "U",
                          paste0(Entity, " -  Urban"),
                          Entity))

```

Change units of some vars
```{r}
# Convert shares into percentages  
df<- df %>%
  mutate(value = if_else(grepl("headcount_ratio|income_gap_ratio|poverty_gap_index",new_varnames),
                         value*100,
                         value))

```

Add calculated vars
```{r}
new_vars<- list()

# Calculate daily shortfall from annual shortfall
new_vars[["daily_total_shortfall"]]<- df %>%
  filter(grepl("total_shortall_annual",new_varnames)) %>%
  mutate(new_varnames = str_replace(new_varnames, "total_shortall_annual", "total_shortall_daily"),
         value = value/365)
  

# Calculate absolute shortfall per person in poverty (absolute poverty lines)
new_vars[["avg_shortfall"]]<- df %>%
  filter(grepl("income_gap_ratio",new_varnames) & !grepl("median",new_varnames)) %>%
  mutate(pov_line_text = str_replace(new_varnames, "income_gap_ratio_", "")) %>% #grab poverty line from varname
  mutate(pov_line_math = as.numeric(str_replace(pov_line_text, "_", "."))) %>% #convert povline to numeric
  mutate(new_varnames = str_replace(new_varnames, "income_gap_ratio", "avg_shortfall"),
         value = value/100 * pov_line_math) %>%
  select(-c(pov_line_text, pov_line_math))
  

# Collapse list of new vars into a single data frame and append to main data
df_new_vars_together<- bind_rows(new_vars)

df<- bind_rows(df, df_new_vars_together)




```


Specify which variables to keep for a list of explorers
```{r}

explorer_var_sets<- list()


poverty_var_stubs<- c("headcount_ratio",
                      "headcount",
                      "avg_shortfall",
                      "income_gap_ratio",
                      "total_shortall_daily",
                      "poverty_gap_index")

pov_lines<- c("1_00",
              "1_90",
              "3_20",
              "5_50",
              "10_00",
              "15_00",
              "20_00",
              "30_00",
              "40_00")

pov_stub_line_combos<- expand.grid(poverty_var_stubs = poverty_var_stubs, 
                    pov_lines = pov_lines)
  

explorer_var_sets[["poverty"]]<- paste0(pov_stub_line_combos$poverty_var_stubs, "_", pov_stub_line_combos$pov_lines)
  

  # And so on for other 
# explorer_vars[["across_distribution"]]<- c(
#   
# )


  

```


For each explorer, filter the data for the specified vars, flip back to wide format, and then split by survey data type and save as separate csvs
```{r}

 # Get a vector of names of the different explorers
  explorers<- names(explorer_var_sets)

for(explorer in explorers){
  
  # Filter for specified vars (NB df is still in long format)
  df_explorer<- df %>% filter(new_varnames %in% explorer_var_sets[[explorer]])

  # Flip to long wide format
  df_explorer<- df_explorer %>%pivot_wider(names_from = "new_varnames", values_from = "value")

  # Split by survey data type and save separately
  df_by_survey_type<- list()
  

    # Income only, including extrapolated years
    df_by_survey_type[["inc_extrap"]]<- df_explorer %>%
      filter(datatype == "income")

    # Income only, excluding extrapolated years
    df_by_survey_type[["inc_no_extrap"]]<- df_explorer %>%
      filter(IsSurveyYear == TRUE,
             datatype == "income")

    # Consumption only, including extrapolated years
    df_by_survey_type[["cons_extrap"]]<- df_explorer %>%
      filter(datatype == "consumption")
    
    # Consumption only, excluding extrapolated years
    df_by_survey_type[["cons_no_extrap"]]<- df_explorer %>%
      filter(IsSurveyYear == TRUE,
             datatype == "consumption")
    
    # Both income and consumption, including extrapolated years
    df_by_survey_type[["inc_or_cons_extrap"]]<- df_explorer
    
    # Both income and consumption, excluding extrapolated years
    df_by_survey_type[["inc_or_cons_no_extrap"]]<- df_explorer %>%
      filter(IsSurveyYear == TRUE)
    
    
  # Get a vector of names of the different survey types
  survey_types<- names(df_by_survey_type)
  
  # save the separated csvs
  for(survey_type in survey_types){
    
  filename<- paste0(survey_type,".csv")
  fp<- paste0("data/", explorer, "/", filename)
  
  write.csv(df_by_survey_type[[survey_type]], fp, row.names = FALSE)
  
  }
  

  
}



```


## Prep the controls

Pull in the control stubs
```{r}

xlsx_url <- "https://raw.githubusercontent.com/owid/notebooks/main/JoeHasell/Povcal_data_work/Povcal_PIP_explorer/control_stubs.xlsx"

control_stubs_sheet_name<- "control_stubs"

# Load the stubs as a dataframe
control_stubs<- read.xlsx(xlsx_url, sheet = control_stubs_sheet_name)

```

Make a vector of the names of the other sheets (these are the Aux sheets, which will be used to multiply-up the control stubs, replacing the various combination of values contained in the Aux sheets)
```{r}

wb<- loadWorkbook(xlsx_url)

# a vector of the names of the other sheets (the Aux vars)
aux_sheets<- names(wb)
aux_sheets<- aux_sheets[aux_sheets != "control_stubs"]

```


The first step in multiplying up the control stubs is to convert the dataframe of control stubs to a list of rows.
```{r}

running_list<- split(control_stubs, seq(nrow(control_stubs)))

```


###Functions to multiply up the control stubs with the Aux values

This function takes a dataframe (`df_block`) and within it replaces a set of key words for a set of values. The key words and replacement values are specified by `sheet_name` (string) and `replacements_row` (a 1 row dataframe). The key words are strings, constructed as "[`sheet_name`$`column_header`]", where `column_header` is each of the variable names in `replacements_row`. The replacement values are the corresponding values of `replacements_row`.

```{r}
myReplaceFun<- function(df_block, sheet_name, replacements_row){
  
    # Backslashes for regex special character escapes
  search_for_strs<- paste0("\\[", sheet_name, "\\$", names(replacements_row), "\\]")
  
  replace_with_strs<- as.vector(t(replacements_row))

  replace_vector_over_col <- function(x) (str_replace_all(x, setNames(replace_with_strs,search_for_strs)))
  
  df_block_replaced<- df_block %>% 
      mutate(across(everything(), replace_vector_over_col))

  return(df_block_replaced)
  }
    

```

Test this function
```{r}
df_block<- data.frame(col1 = c("headcount_ratio_[abs_povline$slug_suffix]","headcount_[abs_povline$slug_suffix]"), 
                      col2 = c("$[abs_povline$text] a day","$[abs_povline$text] a day"))

sheet_name<- "abs_povline"

replacements_row<- data.frame("text" = "1",
                              "slug_suffix" = "1_00",
                              "math" = "1")



kable(myReplaceFun(df_block = df_block,
                            sheet_name = sheet_name,
                            replacements_row = replacements_row))

```

A function that splits a dataframe (`df_replacements_rows`, where each row is a replacements_row in myReplaceFun) into a list of dataframes by row, applies the myReplaceFun on each of those rows, and then aggregates the resulting list back into a single dataframe. The arguments `df_block` and `sheet_name` are passed to myReplaceFun for all rows.
```{r}
applymyReplaceFunRowwise<- function(df_block, sheet_name, df_replacements_rows){

 list_replacements_rows<- split(df_replacements_rows, seq(nrow(df_replacements_rows)))
 
 list_replaced_df_blocks<- lapply(list_replacements_rows, myReplaceFun, df_block = df_block, sheet_name = sheet_name)

  df_replaced_df_blocks<- bind_rows(list_replaced_df_blocks)

  return(df_replaced_df_blocks)

}  
  
```

Test this function
```{r}

df_block<- data.frame(col1 = c("headcount_ratio_[abs_povline$slug_suffix]","headcount_[abs_povline$slug_suffix]"), 
                      col2 = c("$[abs_povline$text] a day","$[abs_povline$text] a day"))

sheet_name<- "abs_povline"

df_replacements_rows<- data.frame("text" = c("1", "2"),
                                  "slug_suffix" = c("1_00", "2_00"),
                                  "math" = c("1", "2"))



kable(applymyReplaceFunRowwise(df_block = df_block,
                            sheet_name = sheet_name,
                            df_replacements_rows = df_replacements_rows))


```


Now lets run applymyReplaceFunRowwise iteratively. In the first iteration, it runs across the list containing the control stubs. The output of this first iteration is a list of (multirow) dataframes which is the control stubs multiplied up by only one set of Aux values. Further iterations then run across this list of dataframes, which itself outputs a list of dataframes. And so on, for each Aux sheet.

```{r}
for(aux_sheet in aux_sheets){
  
  df_replacements_rows<- read.xlsx(xlsx_url, sheet = aux_sheet)
    
    running_list<- lapply(running_list, applymyReplaceFunRowwise, sheet_name = aux_sheet, df_replacements_rows =  df_replacements_rows)
   
}

# collapse the output into a single df
controls_multiplied_up<- bind_rows(running_list)

# drop any duplicate rows (these will be created where a control stub row doesn't make use of all Aux sheets)
controls_multiplied_up<-  controls_multiplied_up %>% distinct()


```

Write controls to csv
```{r}

write.csv(controls_multiplied_up, "poverty_explorer_controls.csv", row.names = FALSE, na = "")

```
